<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java_Reference 四种引用及代码实例</title>
    <link href="/2021/08/24/javReference/"/>
    <url>/2021/08/24/javReference/</url>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>学习guavaCache的时候遇到的一些比较模糊的地方，之前复习过的，现在又忘了，写个blog记录一下下。</p><h3 id="Java-四种引用"><a href="#Java-四种引用" class="headerlink" title="Java 四种引用"></a>Java 四种引用</h3><h4 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用 Strong Reference"></a>强引用 Strong Reference</h4><blockquote><p>日常开发我们锁创建的引用就是强引用。例子：Student obj=new Student();</p></blockquote><h4 id="软引用-Solf-Reference"><a href="#软引用-Solf-Reference" class="headerlink" title="软引用 Solf Reference"></a>软引用 Solf Reference</h4><blockquote><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。</p><p>Java中需要使用SoftReference来使用软引用</p><p>如果一个对象<strong>惟一剩下的引用是软引用</strong>，那么该对象是软可及的（softly reachable）。垃圾收集器并不像其收集弱可及的对象一样尽量地收集软可及的对象，相反，它只在真正 “需要” 内存时才收集软可及的对象。</p></blockquote><h4 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用 Weak Reference"></a>弱引用 Weak Reference</h4><blockquote><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><p>如果一个对象<strong>惟一剩下的引用是弱引用</strong>，那么该对象是软可及的（softly reachable）。垃圾收集器会尽量地收集弱可及的对象。</p></blockquote><h4 id="虚引用-Phantom-Reference"><a href="#虚引用-Phantom-Reference" class="headerlink" title="虚引用 Phantom Reference"></a>虚引用 Phantom Reference</h4><blockquote><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p></blockquote><h4 id="引用队列（ReferenceQueue）"><a href="#引用队列（ReferenceQueue）" class="headerlink" title="引用队列（ReferenceQueue）"></a>引用队列（ReferenceQueue）</h4><blockquote><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p></blockquote><h3 id="各个引用类型测试代码"><a href="#各个引用类型测试代码" class="headerlink" title="各个引用类型测试代码"></a>各个引用类型测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Classname</span> FourReferenceTest</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> 四种引用的测试  配置参数 -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> lqhao</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2021/8/17 11:32</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FourReferenceTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; rq = <span class="hljs-keyword">new</span> ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1M = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//测试强引用</span><br><span class="hljs-comment">//        testStrongReference();</span><br>        <span class="hljs-comment">//测试弱引用</span><br><span class="hljs-comment">//        testSoftReference();</span><br>        <span class="hljs-comment">//测试强引用</span><br><span class="hljs-comment">//        testWeakReference();</span><br>        <span class="hljs-comment">//测试引用队列</span><br>        testReferenceQueue();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStrongReference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 当 new byte为 1M 时，程序运行正常</span><br><span class="hljs-comment">//        byte[] buff = new byte[1024 * 1024 * 1];</span><br>        <span class="hljs-comment">// 当 new byte为 3M 时，程序直接报错，强引用并不会被回收</span><br>        <span class="hljs-keyword">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1M * <span class="hljs-number">3</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSoftReference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1M];<br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; sr = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(buff);<br>            list.add(sr);<br>        &#125;<br><br>        System.gc(); <span class="hljs-comment">//主动通知垃圾回收</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;<br>            Object obj = ((SoftReference) list.get(i)).get();<br>            System.out.println(obj);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWeakReference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1M];<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; sr = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(buff);<br>            list.add(sr);<br>        &#125;<br><br>        System.gc(); <span class="hljs-comment">//主动通知垃圾回收</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;<br>            Object obj = ((WeakReference) list.get(i)).get();<br>            System.out.println(obj);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testReferenceQueue</span><span class="hljs-params">()</span></span>&#123;<br>        Object value = <span class="hljs-keyword">new</span> Object();<br>        Map&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>                WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; k;<br>                <span class="hljs-keyword">while</span>((k = (WeakReference) rq.remove()) != <span class="hljs-keyword">null</span>) &#123;<br>                    System.out.println((cnt++) + <span class="hljs-string">&quot;回收了:&quot;</span> + k);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span>(InterruptedException e) &#123;<br>                <span class="hljs-comment">//结束循环</span><br>            &#125;<br>        &#125;);<br>        thread.setDaemon(<span class="hljs-keyword">true</span>);<br>        thread.start();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">1000</span>;i++) &#123;<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1M];<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt;(bytes, rq);<br>            map.put(weakReference, value);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;map.size-&gt;&quot;</span> + map.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Just lose it</title>
    <link href="/2021/08/14/it/"/>
    <url>/2021/08/14/it/</url>
    
    <content type="html"><![CDATA[<p>各位读者：</p><p>​    大家好。经过了半个多月的酝酿，awakeyoyoyo①终于下定决心，重新拾起写博客的习惯。自始第一件事情就是将之前大三写的卢瑟②博客网站彻底关闭。蛮不舍的。“上一次这么不舍的时候，还是上一次。”</p><blockquote><p>① 昔日博客网站的URL，根据站长花名阿围音译而来，由于不可抗拒因数（穷），买不起awake.com域名，无奈加以三个yo为自己呐喊。</p><p>② 出自人物NBA火箭队名宿卢瑟·海德，音译过来即为loser。</p></blockquote><p>​    由于阿围经常性不间断不想学习。导致之前的博客网站疏于管理，于前不久由莫名其妙的BUG影响已经崩了，说来惭愧作为站长且唯一开发者的ta，也是无意间上班摸鱼手滑点了点那熟悉的浏览器书签才发现。</p><blockquote><p>侧面反映博客网站极少更新以至于无人问津。</p></blockquote><p>​    自2018年”与我常在’Blog”③建站而来，该博客网站从来没有在崩溃’404 NOT FOUND’之后的24小时以内未被人@提醒。如果按照阿围写本文的时间来算，网站累计崩溃时长已超过几个多月，成为近3年来最简单无声的落幕谢场。</p><blockquote><p>③ 阿围的第二个发布于互联网上的网站。代表着当时阿围编程的最高水平。现在看来随便来个黑猫，白猫看上几分钟入门教程都可以用Hexo搭建一个比其酷炫百倍千倍的博客网站。从而成为一只有用的猫。</p></blockquote><p>​    但是，简单的鼓掌，简单的谢场，永远不是完场；或者是沉迷了许久鸡汤，又或者是最近工作摸鱼过多心中有愧，阿围又开始为他下一阶段的目标制定大跃进计划，美其名为下一个五年计划。而重塑“与我常在’Blog’“就是这个计划的重要一环。</p><p>​    阿围的博客网站的名称不忘初心，依旧是熟悉的”与我常在‘Blog”，该网站是基于Hexo+Github pages来搭建的，走的是极致的省钱模式。省去了服务器钱，省去了域名的钱，换来的是其他读者可能需要翻墙或者该host文件才可以访问到。阿围陈述道：“无所谓啦，反正也没啥人看是吧，Just lose it~~~”</p><p>​    由”以前的怯，就输一辈子“到“Just lose it”。一个黄昏，广州珠江边的风刚停，天上映着粉色的晚霞。街上的车、街上的人都在赶着做某件事，而啊围一直在看云。那一瞬间，他忽然感觉到，自己可能真的要融入这个打工人的团体了。啊围意识到，网上流传的躺平的人，并不是害怕失败，而是害怕每天坐着重复的事情，走着重复的路。</p><p>​    看着街上的人来人往，阿围眼光一刻也没有多停留，因为他不知道自己以后是否也会成为其中一员，他也不知道自己是否可以在坚持写博客这条路上走多久。生活嘛，本来就应该用来享受，而不是每天用一句“怯，就输一辈子”来让自己持续奋斗下去。</p><p>​    还是那句话退一寸有退一寸的欢喜。Just lost it.   </p><blockquote><p>在我们心里，just lose it的认输心态，绝非向命运低头，放弃反抗的懦夫行径。恰恰相反，它告诉我们，要从“从来如此便是对的”的逻辑中跳脱出来，追问自己的价值，在无人经过的荒芜中，走出一条新的路。</p><p>​                                                                                                                                出自 北大中文男足 Just lose it</p></blockquote><p>​    本文参考文献——–北大中文男足公众号多篇推送</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
